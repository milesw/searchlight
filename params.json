{"name":"Searchlight Documentation","tagline":"Easily deploy a searchlight application for your VIVO database","body":"*  [Introduction](#introduction)\r\n*  [Quick Start Tutorial](#quick-start-tutorial)\r\n  *  [Setting up a Development Environment](#setting-up-a-development-environment)\r\n  *  [Creating a Searchlight Bookmarklet](#creating-a-bookmarklet)\r\n  *  [Creating a Searchlight Widget](#creating-a-widget)\r\n  *  [Writing a Search Module](#writing-a-search-module)\r\n  *  [Querying a Search Index](#querying-a-search-index)\r\n  *  [Populating the ResultSet](#populating-the-result-set)\r\n  *  [Finishing Up](#finishing-up)\r\n*  [Dependencies](#dependencies)\r\n  *  [Client](#client)\r\n  *  [Server](#server)\r\n*  [Directory Structure](#directory-structure)\r\n*  [Objects Available to your Search Module](#objects-available-to-your-search-module)\r\n  *  [SearchableDocument](#searchabledocument)\r\n     *  [Properties](#properties)\r\n     *  [Methods](#methods)\r\n     *  [Extending the SearchableDocument object](#extending-the-searchabledocument-object)\r\n  *  [ResultSet](#resultset)\r\n     *  [Properties](#properties-1)\r\n     *  [Methods](#methods-1)\r\n*  [Making Requests to a Search Index](#making-requests-to-a-search-index)\r\n  *  [The Request Module](#the-request-module)\r\n*  [Creating a custom view template](#creating-a-custom-view-template)\r\n*  [Public Assets (stylesheets, javascript, images)](#public-assets-stylesheets-javascript-images)\r\n*  [Custom Client Side Behavior](#custom-client-side-behavior)\r\n*  [Building the Front End](#building-the-front-end)\r\n*  [Error Handling](#error-handling)\r\n  *  [Handling an Error](#handling-an-error)\r\n  *  [Error Logging](#error-logging)\r\n\r\n---\r\n<a name=\"introduction\"></a>\r\n#Introduction\r\nSearchlight is a simple application development framework that allows any organization with a VIVO database to quickly and easily deploy a VIVO searchlight application of their own.\r\n\r\nTo learn more about VIVO searchlight apps and see a demo, check out our [about page](http://about.vivosearchlight.org).\r\n\r\nWhile searchlight is a node.js application, it was designed to abstract away as much node / JavaScript specific domain knowledge as possible - as many developers working on the VIVO project may not be familiar with JavaScript (especially on the server).\r\n\r\n---\r\n<a name=\"quick-start-tutorial\"></a>\r\n#Quick Start Tutorial\r\n\r\n<a name=\"setting-up-a-development-environment\"></a>\r\n###Setting up a Development Environment (Linux)\r\nFor Mac or Windows specific development environments, please see the [node](http://nodejs.org/api/index.html), [git](http://git-scm.com/documentation) and [NPM](https://npmjs.org/doc/) documentation. \r\n\r\n*  [Install node.js version 0.8.12](https://github.com/joyent/node/wiki/Installation#building-on-gnulinux-and-other-unix)\r\n*  ```$ git clone http://git.github.com/ragle/searchlight```\r\n*  ```$ cd searchlight```\r\n*  ```$ npm install```\r\n\r\n---\r\n<a name=\"creating-a-bookmarklet\"></a>\r\n###Creating a Bookmarklet\r\n\r\nBelow is the world's simplest HTML document. You'll probably want to create a better landing page than this ([see our demo](http://about.vivosearchlight.org)), but for testing, this is fine. \r\n\r\nSimply create an HTML document using the code below, navigate to the document in your browser, and drag the link you see up to your browser's bookmark bar. \r\n\r\n```html\r\n<html>\r\n  <head></head>\r\n  <body>\r\n    <h1>My Great Searchlight App!</h1>\r\n    <p> Drag the link below to your browser's bookmark bar to install the bookmarklet!</p>\r\n    <a href=\"javascript:(function(){var bar=document.getElementById('vivoSearchLightFrame');if(!bar){bar=document.createElement('div');bar.setAttribute('id','vivoSearchLightFrame');document.getElementsByTagName('body')[0].appendChild(bar);var script=document.createElement('SCRIPT');script.type='text/javascript';script.src='127.0.0.1:3000/javascripts/loader.js';document.getElementsByTagName('head')[0].appendChild(script)}else if(bar.toggle!==undefined){bar.toggle()}})();\">VIVO Searchlight</a>\r\n  </body>\r\n</html>\r\n```\r\n\r\n---\r\n<a name=\"creating-a-widget\"></a>\r\n###Creating a Widget\r\n\r\nYou might also like to use a searchlight widget on one of your organization's pages. For example, you may have a news page that is updated regularly, and you'd like to always display VIVO profiles relevant to your latest updates. \r\n\r\nBelow is a very simple example of an HTML document with an embedded searchlight widget. You can deploy as many widgets as you'd like, in concert with the bookmarklet app.\r\n\r\n```html\r\n<html>\r\n  <head></head>\r\n  <body>\r\n    <h1>My Great Searchlight Widget!</h1>\r\n    <h3> Here is some news about my organization!</h3>\r\n    <p> Today, scientists discovered that by doing experiments and other research, they could learn a lot about the world around them.</p> \r\n    <div id=\"vsl-widget-frame\"></div>\r\n    <script>\r\n      (function(){var script=document.createElement('SCRIPT');script.type='text/javascript';script.src='http://127.0.0.1:3000/javascripts/loader.js';document.getElementsByTagName('head')[0].appendChild(script)})();\r\n    </script>\r\n  </body>\r\n</html>\r\n```\r\n\r\n---\r\n<a name=\"writing-a-search-module\"></a>\r\n###Writing a Search Module\r\nThe framework expects your search module (```customizations/search.js```) to export a single function, ```exports.execute(SearchableDocument, ResultSet, next){}```. \r\n\r\nOn a fresh instalation of the framework, the following code exists in ```customizations/search.js``` to help get you started.\r\n\r\n```javascript\r\n/*\r\n*Module Dependencies\r\n*/\r\nvar bond = require('bond'),\r\n    sanitizer = require('sanitizer'),\r\n    request = require(global.app_path + '/lib/request.js');\r\n\r\n\r\n//Called by Framework - your code goes here\r\nexports.execute = function(SearchableDocument, ResultSet, next){\r\n\r\n  gettingSearchableDocument = SearchableDocument.init(true);\r\n\r\n  gettingSearchableDocument.then(function(){\r\n\r\n    //  inspect the main content of the document the client sent you\r\n    console.log(SearchableDocument.queryText);\r\n\r\n    //  Send an empty result set to the client\r\n    ResultSet.send();\r\n\r\n  });\r\n\r\n};\r\n```\r\n\r\nLet's look at the ```execute()``` function line-by-line to see what's happening. \r\n\r\n```javascript\r\ngettingSearchableDocument = SearchableDocument.init(true);\r\n```\r\n\r\nHere, we are using the [SearchableDocument](#searchabledocument) object's [init()](#searchabledocumentinitreadabilityparse) function to extract main content from the page the client sent us. The ```init ()``` function returns a promise. For our purposes, think of a promise as a function that will execute as soon as something else finishes. It's \"promising\" to do something later, when something else is done. In this case, that \"something else\" is the [readabilityParse()](#searchabledocumentreadabilityparse) function (which can take a bit of time on a larger document).\r\n\r\nOnce readability is done extracting main content, we can do something with our searchable document (as *promised*) in the next block of code: \r\n\r\n```javascript\r\ngettingSearchableDocument.then(function(){\r\n\r\n  // inspect the main content of the document the client sent you\r\n  console.log(SearchableDocument.queryText);\r\n\r\n  // Send an empty result set to the client\r\n  ResultSet.send();\r\n\r\n});  \r\n\r\n```\r\n\r\nRemember how I said that promises are functions? That's not entirely true. The thing we want from the promise we got back from ```init()``` *is* a function though. Specifically, we want the promise objects' ```then``` function, which is the one that executes once that \"something else\" (readability) is finished. There is a lot more going on here - but it isn't important for our simple example! :) \r\n\r\nSo, we pass an anonymous function to ```then```, which will be executed when ```then``` is called. Confused yet? Don't be. All this means is that the code you see within the brackets () after ```then``` will be exectued when ```then``` is called (when our promise is resolved - after readability finishes its work). \r\n\r\nThe SearchableDocument now has a [queryText](#querytext) property available for us. This is the string we will be sending to our search index (e.g. Solr / ElasticSearch, etc) to try to find some relevant VIVO results for the user. \r\n\r\nWe then see what's inside ```queryText``` by logging it to the console: \r\n\r\n```javascript\r\nconsole.log(SearchableDocument.queryText);\r\n```\r\n\r\nFor now, we don't have any results for the user, so let's just send an empty result set using the [ResultSet](#resultset) object's [send()](#resultsetsend) function. \r\n\r\n```javascript\r\nResultSet.send();\r\n```\r\n\r\nNow start up the server: \r\n```bash\r\n$ node app.js\r\n```\r\n\r\nIf you've already [installed the bookmarklet](#creating-the-bookmarklet), you can run it on a page of your choice! Congratulations, you've just processed your first searchlight request, start to finish!\r\n\r\n---\r\n<a name=\"querying-a-search-index\"></a>\r\n###Querying a Search Index\r\nNow that we're successfully processing requests to our app, let's try to find some VIVO profiles relevant to the text the client sent us. \r\n\r\nInstalling and configuring a Search Index falls outside the scope of both the searchlight application and this quick start guide. If you haven't already set up a search index for your VIVO database, you might try [Solr](http://lucene.apache.org/solr/) or [ElasticSearch](http://www.elasticsearch.org/). We've successfully deployed searchlight apps using both, although ElasticSearch has performed better in our experience. \r\n\r\nLet's assume you have a Solr search index listening for requests at the url: ```http://www.example.com/Solr/Select/```. \r\n\r\nLet's create a separate function to query it for profiles relevant to our ```queryText```.  \r\n\r\n```javascript\r\nvar getVivoProfiles = function(SearchableDocument, ResultSet, Next){\r\n\r\n  var requestURL = \"http://www.example.com/Solr/Select/\"\r\n\r\n  var solrParams = {\r\n    \"qt\":\"mlt\",\r\n    \"mlt.minwl\": 5,\r\n    //More Solr MLT params here\r\n    \"wt\": \"json\",\r\n    \"stream.body\": SearchableDocument.queryText\r\n  };\r\n\r\n  var gettingResults = request.post(requestURL, solrParams, next);\r\n  \r\n  gettingResults.then(function(results)){\r\n    console.log(results.response.hits);\r\n  } ;\r\n\r\n}\r\n\r\n```\r\n\r\nWe first specify the URL we are making a request to, and some [params Solr will want](http://wiki.apache.org/solr/MoreLikeThis) in ```requestURL``` and ```solrParams``` respectively. \r\n\r\nWe then call the [request module](#the-request-module)'s [post()](#posturi-opts-next) function, which returns a promise to deliver the response as soon as it has arrived. \r\n\r\nOnce the response arrives from the search index, our promise is resolved, and ```gettingResults.then``` executes the anonymous function we provided it.\r\n\r\nYou'll need to call the function we just created (```getVivoProfiles```) from within ```execute()```. \r\n\r\nIf all goes well, you should see a JSON object full of relevant VIVO profiles in your console!\r\n\r\n---\r\n<a name=\"populating-the-result-set\"></a>\r\n###Populating the Result Set\r\n\r\nNow that we have some profiles, let's get them into our [ResultSet](#resultset) object so we can send them to the client. \r\n\r\nAssuming you followed the directions above, let's say you have some results from Solr stored in a variable called ```solrResults```. \r\n\r\nYou could add the following code to the function ```getVivoProfiles()```:\r\n\r\n```javascript\r\nfor (var i in solrResults){\r\n  var params ={\r\n    name:results[i].name,\r\n    //Populate other params...\r\n    overview: results[i].description\r\n  }\r\n  ResultSet.addResult(params);\r\n}\r\n\r\nResultSet.send()\r\n\r\n```\r\n\r\nHere we are iterating through the solrResults, and adding results using the [ResultSet](#resultset) object's [addResult()](#resultsetaddresultparams) method.\r\n\r\nOnce we're done, we call [ResultSet.send()](#resultsetsend), and our view engine renders the result set for the client.\r\n\r\nOf course, this is a very simplistic example. Depending on how complex the data structure you get back from your search index is - you may have to do additional data marshaling or processing. You'll probably want to move functionality relevant to the ResultSet over to it's own function, and do all sorts of other cool stuff as well. \r\n\r\n---\r\n<a name=\"finishing-up\"></a>\r\n###Finishing Up\r\nAssuming you've installed the bookmarklet and have properly set up your search index - you should be seeing results in the client side app! \r\n\r\nWe've glazed over some of the details here, of course. Unfortunately, we can't provide a completely ready made solution, because search index configurations, parameters and responses will vary wildly.  \r\n\r\nFeel free to log an issue and make a pull request if you find any errors!\r\n\r\n<a name=\"dependencies\"></a>\r\n#Dependencies\r\n<a name=\"client\"></a>\r\n##Client Side Dependencies\r\n\r\nThe client side dependencies are met for you within the ```/public/javascripts/``` directory. Currently, they include:\r\n*  [jQuery](http://api.jquery.com/) - for DOM manipulation, UI functionality & AJAX functionality\r\n*  [Porthole](http://ternarylabs.github.com/porthole/) - To provide a proxy for cross domain requests to the node-vivo-searchlight server\r\n<a name=\"server\"></a>\r\n##Server Side Dependencies\r\n\r\nAll of these dependencies can be satisfied automatically by running ```npm install``` after cloning into the searchlight repo. (See the [quick start tutorial](#quick-start-tutorial) on [setting up a dev environment](#setting-up-a-development-environment-linux) for more details). \r\n\r\nA number of fantastic 3rd party node.js packages / libraries were used in the development of node-vivo-searchlight. In general, the use of these libraries is abstracted for you and you will not need to use them in your code - with the exception of a search index client, sanitizr and perhaps bond if you like to handle asynchronous operations with promises. \r\n\r\n*  [express](https://github.com/visionmedia/express) - As a router and web application framework\r\n*  [EJS](https://github.com/visionmedia/ejs) - As a view templating engine\r\n*  [grunt](https://github.com/gruntjs/grunt) - As a front-end build system\r\n*  [sanitizer](https://github.com/theSmaw/Caja-HTML-Sanitizer) - As a means of escaping HTML special characters / Sanitizing HTML\r\n*  [node-readability](https://github.com/arrix/node-readability) - As a method of extracting main content from a DOM object\r\n*  [bond](https://github.com/pete-otaqui/bond) - As a simple promises library to handle asynchronous operations gracefully\r\n*  [jQuery](https://github.com/coolaj86/node-jquery) - As a simple wrapper on the jQuery library for server-side use\r\n*  [request](https://github.com/mikeal/request) - As a means of making HTTP requests to remote servers as necessary\r\n*  [winston](https://github.com/flatiron/winston) - For async error logging / reporting\r\n\r\n---\r\n<a name=\"directory-structure\"></a>\r\n#Directory Structure\r\n\r\nYou should really only ever be modifying code in the ```customizations/``` directory, unless you need to do some framework hacking for your use case.\r\n\r\n\r\n```\r\n├── customizations                //  Your custom search code goes here\r\n|   |\r\n│   ├── public                        //  extend client side styles and behavior\r\n│   ├── SearchableDocument.js         //  Extends /lib/SearchableDocument.js\r\n│   ├── search.js                     //  Your custom search module\r\n│   └── views                         //  Overide EJS templates in /views\r\n|\r\n|\r\n├── lib                           //  Framework Library\r\n|   |\r\n│   ├── Client                        //  Directory containing Client Side Application code\r\n│   ├── ErrorHandler.js               //  Custom error handling middleware for express\r\n│   ├── request.js                    //  Provides simplified HTTP requests\r\n│   ├── ResultSet.js                  //  Provides standardized data structure for default view  \r\n│   ├── SearchableDocument.js         //  Simple API for server side DOM access\r\n│   ├── build.js                      //  Application build logic\r\n│\r\n├── logs\r\n│   └── error.log.json                //  Winston error log\r\n|\r\n├── node_modules                      //  3rd party NPM modules\r\n|\r\n├── public                         // Static assets\r\n│   ├── images\r\n│   ├── javascripts\r\n|   |   └── bar_iframe.js             //  iFrame animations, proxies DOM to server\r\n|   |   └── loader.js                 //  loads iFrame, proxies DOM to iFrame, on-page animation\r\n│   └── stylesheets\r\n|       └── bar.css                   //  Styles for default view template\r\n|\r\n└── views                         //  EJS View Templates\r\n|   |\r\n|   ├── bar-iframe.html               //  initial iframe (bookmarklet) content\r\n|   ├── bar-widget.html               //  initial widget content\r\n|   ├── results-iframe.html           //  iframe results\r\n|   ├── results-widget.html           //  widget results\r\n|\r\n├── package.json                  //  Package dependencies\r\n|\r\n└── app.js                        //  Application entry point\r\n```\r\n\r\n---\r\n<a name=\"objects-available-to-your-search-module\"></a>\r\n#Objects available to your search module\r\n\r\n---\r\n<a name=\"searchabledocument\"></a>\r\n#SearchableDocument\r\nServer side DOM wrapper for search request sent from the client. Enables extraction of main content and removal of HTML, JavaScript and CSS.\r\n\r\n[The SearchableDocument object can be easily extended](#extending-the-searchabledocument-object) with methods specific to your use case. Note that manipulating parent SearchableDocument properties prepended by '_' via non-parent methods may have unintended consequences.\r\n\r\n<a name=\"properties\"></a>\r\n##Properties\r\n###```wordCount```\r\n*int* Contains a word count. Set by ```SearchableDocument.setWordCount()```\r\n\r\n###```queryText```\r\n\r\n*string* - Contains the best text available (as determined by ```init()```) for querying the search index of your choice\r\n\r\n###```_DOM```\r\n\r\n*string* - Contains the DOM of the page a request was sent from\r\n\r\n###``` _MCHTML ```\r\n\r\n*string* - The main content (as determined by readability) as HTML\r\n\r\n###```_MCText```\r\n\r\n*string* - The main content (as determined by readability) as Text\r\n\r\n###```_$```\r\n\r\n*Object* - Contains a server side jQuery object. Can be used in your DOM manipulation methods if you extend the Searchable Document object for your own use case. \r\n\r\n<a name=\"methods\"></a>\r\n##Methods\r\n###```SearchableDocument.init(readabilityParse)```\r\n\r\n**Params**\r\n  *  ```readabilityParse``` - **boolean** - set to True if you want node-readability to attempt to extract main content from the DOM.\r\n\r\n**Description** - Extract main content with readability if ```readabilityParse``` is set to true and set the ```MCHTML``` and ```MCText``` properties. If ```MCText``` is defined, set the ```queryText``` property to MCText. Otherwise, set ```queryText``` to the DOM, stripped of all JavaScript and HTML.\r\n\r\n**Returns** - void\r\n\r\n**Post Condition** - ```SearchableDocument.queryText``` is available to be sent to a Search Index of your choice\r\n\r\n---\r\n###```SearchableDocument.readabilityParse()```\r\n\r\n**Params** - none\r\n\r\n**Description** - attempts to extract main content from a DOM. See [node-readability](https://github.com/arrix/node-readability) more information. \r\n\r\nNote that using readability almost *always* improves search results in our experience - but it can be expensive. On a basic AWS instance, large documents (>3000 words) took up to 5 seconds during testing. Smaller documents tend to process very quickly, however. \r\n\r\n**Returns** - void\r\n\r\n**Post Condition** - ```SearchableDocument.MCHTML``` is populated with the document's main content as HTML\r\n\r\n---\r\n\r\n###```SearchableDocument.setMCText()```\r\n\r\n**Params** - none\r\n\r\n**Description** - sets the ```_MCText``` property to the contents of ```_MCHTML```, stripped of HTML\r\n\r\n**Returns** - true on success, false on failure (i.e. ```SearchableDocument.MCHTML``` has not yet been set)\r\n\r\n**Pre-Condition** - ```SearchableDocument.MCHTML``` is populated with the document's main content as HTML\r\n\r\n**Post Condition** - ```SearchableDocument.MCHTML``` is populated with the document's main content as Text\r\n\r\n---\r\n\r\n###```SearchableDocument.stripHTML(html)```\r\n\r\n**Params**:\r\n\r\n*  ```html``` - **string** - A string containing valid HTML \r\n\r\n**Description** - Attempts to Strip html from a string, returnins a plain text version on success, the original HTML on failure\r\n\r\n**Returns** - String\r\n\r\n---\r\n\r\n###```SearchableDocument.stripScripts(html)```\r\n\r\n**Params**:\r\n\r\n*  ```html``` - **string** - A string containing valid HTML \r\n\r\n**Description** - Attempts to Strip embedded JavaScript from a string of valid HTML. Returns the HTML stripped of embedded JavaScript on success, the original HTML on failure. \r\n\r\n**Returns** - String\r\n\r\n---\r\n\r\n###```SearchableDocument.checkHasHTML(text)```\r\n\r\n**Params**:\r\n\r\n*  ```text``` - **string**\r\n\r\n**Description** - Attempts to whether or not a string contains HTML\r\n\r\n**Returns** - boolean\r\n\r\n---\r\n\r\n###```SearchableDocument.setWordCount()```\r\n\r\n**Params**: none\r\n\r\n**Description** - Performs a wordcount on the document, and sets the ```wordCount``` property to the result. \r\n\r\nNote that it will check ```queryText``` first, but if it doesn't find anything, it will back track through ```_MCText``` and ```_DOM```, so you can call this function immediately within your search module (before ```init()```), if for example you wanted to write some heuristics to deal with documents of different sizes. \r\n\r\n**Returns** - void\r\n\r\n<a name=\"extending-the-searchabledocument-object\"></a>\r\n##Extending the SearchableDocument Object\r\nYou may need to augment the SearchableDocument object with methods or properties unique to your use case. You can encapsulate this data and behaviour by modifying the object literal ```ExtendSearchableDocument``` within ```/modules/SearchableDocument.js```.\r\n\r\nAny properties or methods you add to this object literal will be added to the prototype of the ```SearchableDocument``` object before it is instantiated. You can therefore use the ```this``` operator safely, as the context of ```this``` will be the instance of ```SearchableDocument``` that you receive in your search module (```/modules/search.js```).\r\n\r\n**Example**\r\n\r\ninside ```/modules/SearchableDocument.js```:\r\n\r\n```javascript\r\nvar ExtendSearchableDocument = {\r\n  foo: 'bar',\r\n  printFoo: function(){console.log(this.foo)};\r\n}\r\n```\r\n\r\ninside ```/modules/SearchableDocument.js```:\r\n```javascript\r\nexports.execute = function(SearchableDocument, ResultSet, err){\r\n    SearchableDocument.printFoo();\r\n    // > 'bar'\r\n}\r\n```\r\n---\r\n<a name=\"resultset\"></a>\r\n#ResultSet\r\nThe ```ResultSet``` Object provides a simple API to create a uniform data structure that the default results view template can consume.\r\n\r\nMore importantly, a method is included to ```send()``` your result set to the rendering engine once you have finished populating it.\r\n\r\n<a name=\"properties-1\"></a>\r\n##Properties\r\n###```list```\r\n*array* - An array containing a list of results to be displayed in the view template\r\n\r\n###```_numResults```\r\n*int* - An integer containing the number of results in your result set. Used and incremented by \r\n```addResult()``` to generate part of a composite key for a DOM id for each result that is added to the result set. \r\n\r\n###```score```\r\n*int* - A subjective measure of how accurate your results are, on a scale of 1-5\r\n\r\n<a name=\"methods-1\"></a>\r\n##Methods\r\n\r\n###```ResultSet.addResult({params})```\r\n\r\n**Params**\r\n*  **params** - an object literal containing data that can be accessed in the results view templates. For the default template:\r\n  *  **params.name** - *String* - The name of the individual or organization\r\n  *  **params.title** - *String* - The title of the individual or organization. \r\n  *  **params.institution_name** - *String* - The name of the institution as it should be displayed next to an overview\r\n  *  **params.institution_shortname** - *String* - The shortened name of the institution as it should be displayed in the results view\r\n  *  **params.image_url** - *String* - The path to the image / thumbnail associated with the individual in the result view\r\n  *  **params.css_image_class** - *String* - An optional class if you intend to extend styles for the image (e.g. change size, etc)\r\n  *  **params.css_id** - *String* - A css id used to define default styles for the result\r\n  *  **params.uri** - *String* - The URI of the individual / organization's VIVO profile\r\n  *  **params.overview** - *String* - The bio, description or overview text describing the individual / organization\r\n  *  **params.topics** - *Array* - Any topics, keywords or areas of research associated with the individual or association\r\n\r\n**Description** - accepts a params object containing meta data about a result. It will add this meta data to an array element of ```ResultSet.list```, which will be available to your view template. \r\n\r\nNote that all of the above properties of ```params``` are optional. These are merely listed here for your convenience, as the default results view template expeects them.\r\n\r\nIf you have defined a custom view template, pass in what you need instead. For example, ```ResultSet.addResult({DepartmentName:'Sociology'})``` would add a result with a ```DepartmentName``` property, which would be available to you in your custom results view template.\r\n\r\n**Returns** - void\r\n\r\n---\r\n\r\n###```ResultSet.setScore(score)```\r\n\r\n**Params**:\r\n*  Score - *int* - a number between 1-5 that describes how accurate your result set is.\r\n\r\n**Description** - sets ```ResultSet.score``` to ```score```. Because scoring is highly subjective, you will need to write some logic to decide how accurate the results you are getting back from your search index are on a scale of 1-5. This score is displayed to the user in the default view template. If you are using a custom view template, setting a score isn't strictly necessary. \r\n\r\n---\r\n\r\n###```ResultSet.send()```\r\n\r\n**Params**: none\r\n\r\n**Description** - Passes your ```ResultSet``` instance to the rendering engine, signaling it that your processing is complete and it is safe to send data to the client.\r\n\r\n<a name=\"making-requests-to-a-search-index\"></a>\r\n#Making Requests to a Search Index\r\nWithin your search module (```customizations/search.js```), you will need to query a search index for VIVO profiles relevant to the text you received from the client. A request module is available for you in ```lib/request.js``` that makes this process easier.\r\n\r\n<a name=\"the-request-module\"></a>\r\n#The Request Module\r\nThe request module offers a thin wrapper for [request](https://github.com/mikeal/request) that abstracts error handling and returns promises for responses using [bond](https://github.com/pete-otaqui/bond). Bond is a super simple promises implementation that is really easy to use. See the examples below for more details.\r\n\r\nThe request module is available to you as ```request``` within your search module (```customizations/search.js```). \r\n\r\n##Exports\r\n\r\n###```post(uri, opts, next)```\r\n\r\n**params** \r\n  *  uri - *string* - The URI you are making a request to\r\n  *  opts - *object* - Key value pairs representing request parameters\r\n  *  next - *function* - The express ```next()``` function, used for error handing in this case\r\n\r\n**Description** - Makes a HTTP post request to the specified URI\r\n\r\n**Returns** function (a promise for a HTTP response)\r\n\r\n**Example usage** \r\n\r\n```javaScript\r\nvar request = include(global.app_path + 'lib/result.js');\r\nvar gettingResults = request.post('www.example.com', {id:2}, next);\r\ngettingResults.then(function(results){\r\n    //do something with your results... \r\n});\r\n```\r\n\r\n---\r\n###```get(uri, opts, next)```\r\n\r\n**params** \r\n  *  uri - *string* - The URI you are making a request to\r\n  *  opts - *object* - Key value pairs representing request parameters\r\n  *  next - *function* - The express ```next()``` function, used for error handing in this case\r\n\r\n**Description** - Makes a HTTP get request to the specified URI\r\n\r\n**Returns** function (a promise for a HTTP response)\r\n\r\n**Example usage** \r\n\r\n```javaScript\r\nvar request = include(global.app_path + 'lib/result.js');\r\nvar gettingResults = request.get('www.example.com', {id:2}, next);\r\ngettingResults.then(function(results){\r\n    //do something with your results... \r\n});\r\n```\r\n<a name=\"creating-a-custom-view-template\"></a>\r\n#Creating a Custom View Template\r\nUsing custom view templates for a bookmarklet iframe, widget or result set is easy. Simply follow the naming conventions you see inside ```customizations/views/```. For example - if you would like to use a custom iframe template, replace ```bar-iframe.html.example``` with your own template, ```bar-iframe.html```. \r\n\r\nThe searchlight framework checks first to see if a custom view template exists, and uses it if it is available. Otherwise, the default view template is used to satisfy a request. \r\n\r\n\r\n<a name=\"public-assets-stylesheets-javascript-images\"></a>\r\n#Public Assets\r\nTwo publicly available static directories exist in every searchlight application. The first, is the default ```/public``` directory, which stores image, javascript and style assets for the default view templates.\r\n\r\nThe second can be found at ```customizations/public```, and is used for adding assets for custom view teplates. Anything you put in this directory will be available at ```http://example.com/custom/```. \r\n\r\nSo, to include a custom style sheet within your custom view template in ```/customizations/views```: \r\n```html\r\n<link rel=\"stylesheet\" href=\"/custom/stylesheets/style.css'\" type=\"text/css\">\r\n```\r\n\r\n<a name=\"custom-client-side-behavior\"></a>\r\n#Custom Client Side Behavior\r\nCurrently, there are very few avenues for modifying application specific client side behavior without getting in and hacking framework code in ```lib/client/```. If you need to add analytics code, or some other JavaScript for your use case, you can add it in ```customizations/public/javascripts/custom.js```. \r\n\r\nThis file will be appended to the rest of the client side JavaScript and minified during the [front end build process](#building-the-front-end).\r\n\r\n<a name=\"building-the-front-end\"></a>\r\n#Building the Front End\r\nThe default front end is built for you already. If you need to rebuild it for some reason (e.g. you've been doing some hacking in ```lib/client/```) you can do so by adding ```-b``` as an option when you start the server. \r\n\r\n```bash\r\n$ node app.js -b\r\n```\r\n\r\nThis can also be accomplished with the grunt command line tool, using [grunt](http://gruntjs.com/getting-started): \r\n\r\n```bash\r\n$ grunt default\r\n``` \r\n\r\nThe Gruntfile is located in the root of the project directory, ```Gruntfile.js```.\r\n\r\n<a name=\"error-handling\"></a>\r\n#Error Handling\r\n\r\n<a name=\"handling-an-error\"></a>\r\n###Handling an error\r\nCheck out the [express docs](http://expressjs.com/guide.html#error-handling) for a detailed guide to error handling in express.\r\n\r\nIn the meantime, here is a simple example of how you might handle an error in your search module:\r\n\r\n```javascript\r\n\r\nfunction raiseShields(){\r\n\r\n  sheildStatus = enterprise.shields.up(); // Some code an intern wrote that lowers\r\n                                          // shields and spits out an error instead...\r\n  if(shieldStatus.error){\r\n    enterprise.bones.complain(\"My god Jim...It'll tear the ship apart!\");\r\n    next(shieldStatus.error);\r\n  }\r\n\r\n}();\r\n\r\n```\r\n<a name=\"error-logging\"></a>\r\n###Error Logging\r\n```lib/ErrorHandler.js``` contains a thin wrapper for [Winston](https://github.com/flatiron/winston). It is used internally as middleware for express. Both console and filesystem transports are used for logging, with errors logged in ```/logs/error.log.json```. See the Winston documentation for details about querying the log file programatically - which can be quite useful for testing and debugging. \r\n\r\nCaught exceptions are logged as runtime errors. Uncaught exceptions are logged as such, and the app is killed to prevent attempts to handle future requests in an unknown state. \r\n\r\nFor maximum stability, it is recommended that you use a service like [forever](https://github.com/nodejitsu/forever) to automatically restart the server in the event of an uncaught exception.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}