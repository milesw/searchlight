{"name":"Searchlight Documentation","tagline":"Easily deploy a searchlight application for your VIVO database","body":"*  [Introduction](#introduction)\r\n*  [Quick Start Tutorial](#quick-start-tutorial)\r\n  *  [Setting up a Development Environment](#setting-up-a-development-environment)\r\n  *  [Creating a Searchlight Bookmarklet](#creating-a-bookmarklet)\r\n  *  [Creating a Searchlight Widget](#creating-a-widget)\r\n  *  [Writing a Search Module](#writing-a-search-module)\r\n  *  [Querying a search index](#querying-a-search-index)\r\n  *  [Populating the ResultSet](#populating-the-result-set)\r\n  *  [Finishing Up](#finishing-up)\r\n*  [Dependencies](#dependencies)\r\n  *  [Client](#client)\r\n  *  [Server](#server)\r\n*  [Directory Structure](#directory-structure)\r\n*  [Objects Available to the Search Module](#objects-available-to-your-search-module)\r\n  *  [SearchableDocument](#searchabledocument)\r\n     *  [Properties](#properties)\r\n     *  [Methods](#methods)\r\n     *  [Extending the SearchableDocument object](#extending-the-searchabledocument-object)\r\n  *  [ResultSet](#resultset)\r\n     *  [Properties](#properties-1)\r\n     *  [Methods](#methods-1)\r\n*  [Making Requests to a search index](#making-requests-to-a-search-index)\r\n  *  [The Request Module](#the-request-module)\r\n*  [Creating a custom view template](#creating-a-custom-view-template)\r\n*  [Public Assets (stylesheets, javascript, images)](#public-assets-stylesheets-javascript-images)\r\n*  [Custom Client Side Behavior](#custom-client-side-behavior)\r\n*  [Building the Front End](#building-the-front-end)\r\n*  [Error Handling](#error-handling)\r\n  *  [Handling an Error](#handling-an-error)\r\n  *  [Error Logging](#error-logging)\r\n*  [Deploying the App](#deployment)\r\n\r\n\r\n<a name=\"introduction\"></a>\r\n#Introduction\r\n[Searchlight](https://www.github.com/ragle/searchlight) is a simple application development framework that allows any organization with a VIVO database to quickly and easily deploy a VIVO searchlight application of their own.\r\n\r\nTo learn more about VIVO searchlight apps and see a demo, check out our [about page](http://about.vivosearchlight.org).\r\n\r\nWhile searchlight is a node.js application, it was designed to abstract away as much node / JavaScript specific domain knowledge as possible - as many developers working on the VIVO project may not be familiar with JavaScript (especially on the server).\r\n\r\n<a name=\"quick-start-tutorial\"></a>\r\n#Quick Start Tutorial\r\n\r\n<a name=\"setting-up-a-development-environment\"></a>\r\n###Setting up a Development Environment (Linux)\r\nFor Mac or Windows specific dev environments, please see the [node](http://nodejs.org/api/index.html), [git](http://git-scm.com/documentation) and [NPM](https://npmjs.org/doc/) documentation. \r\n\r\n*  [Install node.js version 0.8.12](https://github.com/joyent/node/wiki/Installation#building-on-gnulinux-and-other-unix)\r\n*  ```$ git clone http://git.github.com/ragle/searchlight```\r\n*  ```$ cd searchlight```\r\n*  ```$ npm install```\r\n\r\n---\r\n<a name=\"creating-a-bookmarklet\"></a>\r\n###Creating a Bookmarklet\r\n\r\nBelow is the world's simplest HTML document. You'll probably want to create a better landing page than this ([see our demo](http://about.vivosearchlight.org)), but for testing, this works. \r\n\r\nSimply create an HTML document using the code below, navigate to the document in your browser, and drag the link you see up to your browser's bookmark bar. \r\n\r\n```html\r\n<html>\r\n  <head></head>\r\n  <body>\r\n    <h1>My Great Searchlight App!</h1>\r\n    <p> Drag the link below to your browser's bookmark bar to install the bookmarklet!</p>\r\n    <a href=\"javascript:(function(){var bar=document.getElementById('vivoSearchLightFrame');if(!bar){bar=document.createElement('div');bar.setAttribute('id','vivoSearchLightFrame');document.getElementsByTagName('body')[0].appendChild(bar);var script=document.createElement('SCRIPT');script.type='text/javascript';script.src='http://127.0.0.1:3000/javascripts/loader.js';document.getElementsByTagName('head')[0].appendChild(script)}else if(bar.toggle!==undefined){bar.toggle()}})();\">VIVO Searchlight</a>\r\n  </body>\r\n</html>\r\n```\r\nBookmarklet view templates exist already for you for the \"skin\" of both the bookmarklet (UI) and the result sets (VIVO profiles). These can be found in ```views/bar-iframe.html``` and ```views/results-iframe.html``` respectively.\r\n\r\nThe default UI and result set views are automatically managed and rendered for you on each request - but if you want to customize them check out the section on [creating custom views](#creating-a-custom-view-template). \r\n\r\n---\r\n<a name=\"creating-a-widget\"></a>\r\n###Creating a Widget\r\n\r\nYou might also like to use a searchlight widget on one of your organization's pages. For example, you may have a news page that is updated regularly and you'd like to always display VIVO profiles relevant to your latest updates. \r\n\r\nBelow is a very simple (and rather ugly) example of an HTML document with an embedded searchlight widget. You can deploy as many widgets as you'd like, in concert with the bookmarklet app.\r\n\r\n```html\r\n<html>\r\n  <head>\r\n  <style>\r\n    #vsl-widget-frame{\r\n      width:700px;\r\n      height:100px;\r\n      border: red dashed 8px;\r\n      background-color: yellow; \r\n    }\r\n  </style>\r\n  </head>\r\n  <body>\r\n    <h1>My Great Searchlight Widget!</h1>\r\n    <h3> Here is some news about my organization!</h3>\r\n    <p> Today, scientists discovered that by doing experiments and other research, they could learn a lot about the world around them.</p> \r\n    <div id=\"vsl-widget-frame\"></div>\r\n    <script>\r\n      (function(){var script=document.createElement('SCRIPT');script.type='text/javascript';script.src='http://127.0.0.1:3000/javascripts/loader.js';document.getElementsByTagName('head')[0].appendChild(script)})();\r\n    </script>\r\n  </body>\r\n</html>\r\n```\r\nMarkup exists for widget views already, and can be found in ```views/bar-widget.html``` and ```views/results-widget.html```. These default views are automatically managed and rendered for you - but if you want to customize them check out the section on [creating custom views](#creating-a-custom-view-template).\r\n\r\nNote that by default the iframe within widgets will use the same default styles as a bookmarklet. To learn how to include a custom stylesheet to style the widget iframe differently, check out the section on [public assets](#public-assets-stylesheets-javascript-images).\r\n\r\n---\r\n<a name=\"writing-a-search-module\"></a>\r\n###Writing a Search Module\r\nThe framework expects your search module (```customizations/search.js```) to export a single function, ```exports.execute(SearchableDocument, ResultSet, next){}```. \r\n\r\nOn a fresh installation of the framework, the following code exists in ```customizations/search.js``` to help get you started.\r\n\r\n```javascript\r\n/*\r\n*Module Dependencies\r\n*/\r\nvar bond = require('bond'),\r\n    sanitizer = require('sanitizer'),\r\n    request = require(global.app_path + '/lib/request.js');\r\n\r\n\r\n//Called by Framework - your code goes here\r\nexports.execute = function(SearchableDocument, ResultSet, next){\r\n\r\n  creatingSearchableDocument = SearchableDocument.init(true);\r\n\r\n  creatingSearchableDocument.then(function(){\r\n\r\n    //  inspect the main content of the document the client sent you\r\n    console.log(SearchableDocument.queryText);\r\n\r\n    //  Send an empty result set to the client\r\n    ResultSet.send();\r\n\r\n  });\r\n\r\n};\r\n```\r\n\r\nLet's look at the ```execute()``` function in detail to see what's happening. \r\n\r\n```javascript\r\ncreatingSearchableDocument = SearchableDocument.init(true);\r\n```\r\n\r\nHere, we are using the [SearchableDocument](#searchabledocument) object's [init()](#searchabledocumentinitreadabilityparse) function to populate some [properties of the SearchableDocument object](#properties) that we will use later to query a search index. \r\n\r\nBecause we pass ```true``` as a parameter to this function, it will also attempt to extract the main content from the page the client sent us using [node-readability](https://github.com/arrix/node-readability).\r\n\r\nThe ```init ()``` function returns a promise. If you're not familiar with promises, they are exactly what they sound like. A promise, in our case to do something once something else finishes. For us, that \"something else\" is the [readabilityParse()](#searchabledocumentreadabilityparse) function (which can take a bit of time on a larger document).\r\n\r\nOnce readability is done extracting main content, we can do something with our SearchableDocument (as *promised*) in the next block of code: \r\n\r\n```javascript\r\ncreatingSearchableDocument.then(function(){\r\n\r\n  // inspect the main content of the document the client sent you\r\n  console.log(SearchableDocument.queryText);\r\n\r\n  // Send an empty result set to the client\r\n  ResultSet.send();\r\n\r\n});  \r\n\r\n```\r\n\r\nLet's look at this a little more abstractly. Forget about what is happening inside the anonymous function we pass to ```then()```.\r\n\r\nLet's look at it like this:\r\n\r\n```javascript\r\ncreatingSearchableDocument.then(\r\n\r\n   //  After \"creating the SearchableDocument\" is finished, \r\n   // **THEN** we can do whatever is in here... \r\n\r\n)\r\n```\r\n\r\nThere is [a lot more to know about promises](http://wiki.commonjs.org/wiki/Promises) if you are interested in wrangling asynchronous operations and callbacks into something sensible - but for the searchlight framework, this is all you really need to know. \r\n\r\n When our promise is resolved (i.e. that \"something else\" is finished), ```then()``` is called, and the code we passed it in the anonymous function is executed:\r\n\r\n ```javascript\r\ngettingSearchableDocument.then(function(){\r\n\r\n  // inspect the main content of the document the client sent you\r\n  console.log(SearchableDocument.queryText);\r\n\r\n  // Send an empty result set to the client\r\n  ResultSet.send();\r\n\r\n});  \r\n\r\n```\r\n\r\n Since ```SearchableDocument.init()``` has finished, our instance of SearchableDocument now has a [queryText](#querytext) property available for us. This is the string we will be sending to our search index (e.g. Solr / ElasticSearch, etc) to try to find some relevant VIVO results for the user. \r\n\r\nWe can see what's inside ```queryText``` by logging it to the console: \r\n\r\n```javascript\r\nconsole.log(SearchableDocument.queryText);\r\n```\r\n\r\nFor now, we don't have any results for the user, so let's just send an empty result set using the [ResultSet](#resultset) object's [send()](#resultsetsend) function. \r\n\r\n```javascript\r\nResultSet.send();\r\n```\r\n\r\nNow that you understand what is happening here - open up your terminal and start up the server: \r\n```bash\r\n$ cd /path/to/searchlight\r\n$ node app.js\r\n```\r\n\r\nIf you've already [installed the bookmarklet](#creating-the-bookmarklet), you can run it on a page of your choice!\r\n\r\nCongratulations, you've just processed your first searchlight request, start to finish!\r\n\r\n---\r\n<a name=\"querying-a-search-index\"></a>\r\n###Querying a Search Index\r\nNow that we're successfully processing requests to our app, let's try to find some VIVO profiles relevant to the text the client sent us. \r\n\r\nInstalling and configuring a search index falls outside the scope of both the searchlight application and this quick start guide. If you haven't already set up a search index for your VIVO database, you might try [Solr](http://lucene.apache.org/solr/) or [ElasticSearch](http://www.elasticsearch.org/). We've successfully deployed searchlight apps using both, although ElasticSearch has performed better in our experience. \r\n\r\nLet's assume you have a Solr search index listening for requests at the uri: ```http://www.example.com:8080/Solr/Select/```. \r\n\r\nLet's create a separate function to query it for profiles relevant to the text contained in our ```SearchableDocument.queryText``` property.  \r\n\r\n```javascript\r\nvar getVivoProfiles = function(SearchableDocument, ResultSet, next){\r\n\r\n  var requestURI = \"http://www.example.com:8080/Solr/Select/\"\r\n\r\n  var solrParams = {\r\n    \"qt\":\"mlt\",\r\n    \"mlt.minwl\": 5,\r\n    //More Solr MLT params here\r\n    \"wt\": \"json\",\r\n    \"stream.body\": SearchableDocument.queryText\r\n  };\r\n\r\n  var gettingResults = request.post(requestURI, solrParams, next);\r\n\r\n  gettingResults.then(function(results){\r\n    console.log(results.response.docs);\r\n  });\r\n\r\n};\r\n\r\n```\r\n\r\nWe first specify the uri we are making a request to, and some [params Solr will want](http://wiki.apache.org/solr/MoreLikeThis) in ```requestURI``` and ```solrParams``` respectively. \r\n\r\nWe then call the [request module](#the-request-module)'s [post()](#posturi-opts-next) function, which returns a promise to deliver the response as soon as it has arrived. \r\n\r\nOnce the response arrives from the search index, our promise is resolved, and ```gettingResults.then``` executes the anonymous function we provided it. Note that the promise delivers the response data as a parameter (```results```) to our anonymous function. \r\n\r\nYou'll need to call the function we just created (```getVivoProfiles```) from within ```execute()```:\r\n\r\n```javascript\r\nexports.execute = function(SearchableDocument, ResultSet, next){\r\n\r\n  creatingSearchableDocument = SearchableDocument.init(true);\r\n\r\n  creatingSearchableDocument.then(function(){\r\n\r\n    getVivoProfiles(SearchableDocument, ResultSet, next);\r\n\r\n  });\r\n\r\n};\r\n```\r\n\r\nIf all goes well, you should see a JSON object full of relevant VIVO profiles in your console! Note that the data structure your Solr instance gives back may not contain ```response.docs```, check your configuration and make sure you are passing around the right data!\r\n\r\n---\r\n<a name=\"populating-the-result-set\"></a>\r\n###Populating the Result Set\r\n\r\nNow that we have some profiles, let's get them into our [ResultSet](#resultset) object so we can send them to the client. \r\n\r\nAssuming you followed the directions above, let's modify our callback for ```gettingResults.then()``` (within our ```gettingVivoProfiles()``` function) to call a new function, which we'll define below. First, the new body of our ```.then()``` callback:\r\n\r\n```javascript\r\n  gettingResults.then(function(results){\r\n    sendResults(results.response.docs, ResultSet, next);\r\n  });\r\n```\r\n\r\nAll we're doing here is passing the profiles we got back from our Solr instance (```results.response.docs```) as the first parameter to a new function, defined below:\r\n\r\n\r\n```javascript\r\nvar sendResults = function(solrResults, ResultSet, next){\r\n\r\n  var res, params;\r\n\r\n  for (var i in solrResults){\r\n    res = solrResults[i];\r\n    \r\n    params = {\r\n      name: sanitizer.sanitize(res.name),\r\n      //Populate other params...\r\n      overview: sanitizer.sanitize(res.description)\r\n    }\r\n\r\n    ResultSet.addResult(params);\r\n  }\r\n\r\n  ResultSet.send()\r\n\r\n};\r\n\r\n```\r\n\r\nHere we are iterating through ```solrResults```, and adding results using the [ResultSet](#resultset) object's [addResult()](#resultsetaddresultparams) method.\r\n\r\nOnce we're done, we call [ResultSet.send()](#resultsetsend) (make sure you're no longer calling this from within ```execute()```), and our view engine renders the result set for the client.\r\n\r\nOf course, this is a very simplistic example. Depending on how complex the data structure you get back from your search index is - you may have to do additional data marshaling or processing. You'll probably want to move functionality relevant to the ResultSet over to its own function, and do all sorts of other cool stuff as well. \r\n\r\n---\r\n<a name=\"finishing-up\"></a>\r\n###Finishing Up\r\nAssuming you've installed the bookmarklet and have properly set up your search index - you should be seeing results in the client side app! \r\n\r\nWe've glazed over some of the details here, of course. Unfortunately, we can't provide a completely ready-made solution because search index configurations, parameters and responses will vary wildly.  \r\n\r\nFeel free to log an issue and make a pull request if you find any errors!\r\n\r\n<a name=\"dependencies\"></a>\r\n#Dependencies\r\n<a name=\"client\"></a>\r\n###Client Side Dependencies\r\n\r\nThe client side dependencies are met for you within the ```public/javascripts/``` directory. Currently, they include:\r\n*  [jQuery](http://api.jquery.com/) - for DOM manipulation, UI functionality & AJAX functionality\r\n*  [Porthole](http://ternarylabs.github.com/porthole/) - To provide a proxy for cross domain requests to the searchlight server\r\n\r\n\r\n<a name=\"server\"></a>\r\n###Server-side Dependencies\r\n\r\nAll of these dependencies can be satisfied automatically by running ```npm install``` after cloning into the searchlight repo. (See the [quick start tutorial](#quick-start-tutorial) on [setting up a dev environment](#setting-up-a-development-environment-linux) for more details). \r\n\r\nA number of fantastic 3rd party node.js packages / libraries were used in the development of searchlight. In general, the use of these libraries is abstracted for you and you will not need to use them in your code - with the exception of sanitizr and perhaps bond if you like to handle asynchronous operations with promises. \r\n\r\n*  [express](https://github.com/visionmedia/express) - As a router and web application framework\r\n*  [EJS](https://github.com/visionmedia/ejs) - As a view templating engine\r\n*  [grunt](https://github.com/gruntjs/grunt) - As a front-end build system\r\n*  [sanitizer](https://github.com/theSmaw/Caja-HTML-Sanitizer) - As a means of escaping HTML special characters / Sanitizing HTML\r\n*  [node-readability](https://github.com/arrix/node-readability) - As a method of extracting main content from a DOM object\r\n*  [bond](https://github.com/pete-otaqui/bond) - As a simple promises library to handle asynchronous operations gracefully\r\n*  [jQuery](https://github.com/coolaj86/node-jquery) - As a simple wrapper on the jQuery library for server-side use\r\n*  [request](https://github.com/mikeal/request) - As a means of making HTTP requests to remote servers as necessary\r\n*  [winston](https://github.com/flatiron/winston) - For async error logging / reporting\r\n\r\n\r\n<a name=\"directory-structure\"></a>\r\n#Directory Structure\r\n\r\nYou should really only ever be modifying code in the ```customizations/``` directory, unless you need to do some framework hacking for your use case.\r\n\r\n\r\n```\r\n├── customizations                //  Your custom search code goes here\r\n|   |\r\n│   ├── public                        //  extend client side styles and behavior\r\n│   ├── SearchableDocument.js         //  Extends /lib/SearchableDocument.js\r\n│   ├── search.js                     //  Your custom search module\r\n│   └── views                         //  Override EJS templates in /views\r\n|\r\n|\r\n├── lib                           //  Framework Library\r\n|   |\r\n│   ├── Client                        //  Directory containing Client Side Application code\r\n│   ├── ErrorHandler.js               //  Custom error handling middleware for express\r\n│   ├── request.js                    //  Provides simplified HTTP requests\r\n│   ├── ResultSet.js                  //  Provides standardized data structure for default view  \r\n│   ├── SearchableDocument.js         //  Simple API for server-side DOM access\r\n│   ├── build.js                      //  Application build logic\r\n│\r\n├── logs\r\n│   └── error.log.json                //  Winston error log\r\n|\r\n├── node_modules                      //  3rd party NPM modules\r\n|\r\n├── public                         // Static assets\r\n│   ├── images\r\n│   ├── javascripts\r\n|   |   └── bar_iframe.js             //  iframe animations, proxies DOM to server\r\n|   |   └── loader.js                 //  loads iframe, proxies DOM to iFrame, on-page animation\r\n│   └── stylesheets\r\n|       └── bar.css                   //  Styles for default view template\r\n|\r\n└── views                         //  EJS View Templates\r\n|   |\r\n|   ├── bar-iframe.html               //  initial iframe (bookmarklet) content\r\n|   ├── bar-widget.html               //  initial widget content\r\n|   ├── results-iframe.html           //  iframe results\r\n|   ├── results-widget.html           //  widget results\r\n|\r\n├── package.json                  //  Package dependencies\r\n|\r\n└── app.js                        //  Application entry point\r\n```\r\n\r\n<a name=\"objects-available-to-your-search-module\"></a>\r\n#Objects available to the search module\r\n\r\n\r\n<a name=\"searchabledocument\"></a>\r\n##SearchableDocument\r\nServer-side DOM wrapper for documents sent from the client for searches. Enables extraction of main content and removal of HTML and JavaScript.\r\n\r\n[The SearchableDocument object can be easily extended](#extending-the-searchabledocument-object) with methods specific to your use case. Note that manipulating parent SearchableDocument properties prepended by '_' via non-parent methods may have unintended consequences. \r\n\r\n<a name=\"properties\"></a>\r\n###Properties\r\n###```wordCount```\r\n*int* - Contains a word count. Set by ```SearchableDocument.setWordCount()```\r\n\r\n<a name=\"querytext\"></a>\r\n###```queryText```\r\n\r\n*string* - Contains the best text available (as determined by ```init()```) for querying the search index of your choice\r\n\r\n###```_DOM```\r\n\r\n*string* - Contains the DOM of the page a request was sent from\r\n\r\n###``` _MCHTML ```\r\n\r\n*string* - The main content (as determined by readability) as HTML\r\n\r\n###```_MCText```\r\n\r\n*string* - The main content (as determined by readability) as Text\r\n\r\n###```_$```\r\n\r\n*Object* - Contains a server-side jQuery object. Can be used in your DOM manipulation methods if you [extend the SearchableDocument object](#extending-the-searchabledocument-object) for your own use case. \r\n\r\n<a name=\"methods\"></a>\r\n###Methods\r\n<a name=\"searchabledocumentinitreadabilityparse\"></a>\r\n###```SearchableDocument.init(readabilityParse)```\r\n\r\n**Params**\r\n  *  ```readabilityParse``` - *boolean* - set to True if you want node-readability to attempt to extract main content from the DOM.\r\n\r\n**Description** - Attempt to set ```_MCHTML``` & ```_MCText``` properties if ```readabilityParse``` is set to true. Set ```queryText``` to the best text available (```_MCText``` or ```_DOM```, stripped of HTML).\r\n\r\n**Returns** - void\r\n\r\n**Post Condition** - ```queryText``` is available to be sent to a search index of your choice\r\n\r\n<a name=\"searchabledocumentreadabilityparse\"></a>\r\n---\r\n###```SearchableDocument.readabilityParse()```\r\n\r\n**Params** - none\r\n\r\n**Description** - attempts to extract main content from a DOM. See [node-readability](https://github.com/arrix/node-readability) for more information. \r\n\r\nNote that using readability almost *always* improves search results in our experience - but it can be expensive. On a basic AWS instance, large documents (>3000 words) took up to 5 seconds during testing. Smaller documents tend to process very quickly, however. \r\n\r\n**Returns** - void\r\n\r\n**Post Condition** - ```_MCHTML``` is populated with the document's main content as HTML\r\n\r\n---\r\n\r\n###```SearchableDocument.setMCText()```\r\n\r\n**Params** - none\r\n\r\n**Description** - sets the ```_MCText``` property to the contents of ```_MCHTML```, stripped of HTML\r\n\r\n**Returns** - true on success, false on failure (i.e. ```_MCHTML``` has not yet been set)\r\n\r\n**Pre-Condition** - ```_MCHTML``` is populated with the document's main content as HTML\r\n\r\n**Post Condition** - ```_MCText``` is populated with the document's main content as Text\r\n\r\n---\r\n\r\n###```SearchableDocument.stripHTML(html)```\r\n\r\n**Params**:\r\n\r\n*  ```html``` - **string** - A string containing valid HTML \r\n\r\n**Description** - Attempts to strip html from a string, returns a plain text version on success, the original HTML on failure\r\n\r\n**Returns** - String\r\n\r\n---\r\n\r\n###```SearchableDocument.stripScripts(html)```\r\n\r\n**Params**:\r\n\r\n*  ```html``` - **string** - A string containing valid HTML \r\n\r\n**Description** - Attempts to strip embedded JavaScript from a string of valid HTML. Returns the HTML stripped of embedded JavaScript on success, the original HTML on failure. \r\n\r\n**Returns** - String\r\n\r\n---\r\n\r\n###```SearchableDocument.checkHasHTML(text)```\r\n\r\n**Params**:\r\n\r\n*  ```text``` - **string**\r\n\r\n**Description** - Attempts to determine whether or not a string contains HTML\r\n\r\n**Returns** - boolean\r\n\r\n---\r\n\r\n###```SearchableDocument.setWordCount()```\r\n\r\n**Params**: none\r\n\r\n**Description** - Performs a word count on the document, and sets the ```wordCount``` property to the result. \r\n\r\n**Returns** - void \r\n\r\n**Post Condition** - ```wordCount``` property is set. \r\n\r\nNote that it will check ```queryText``` first, but if it doesn't find anything, it will back track through ```_MCText``` and ```_DOM```, so you can call this function immediately within your search module (before ```init()```), if for example you wanted to write some heuristics to deal with documents of different sizes. \r\n\r\n**Returns** - void\r\n\r\n<a name=\"extending-the-searchabledocument-object\"></a>\r\n###Extending the SearchableDocument Object\r\nYou may need to augment the SearchableDocument object with methods or properties unique to your use case. You can encapsulate this data and behaviour by modifying the object literal ```ExtendSearchableDocument``` within ```customizations/SearchableDocument.js```.\r\n\r\nAny properties or methods you add to this object literal will be added to the prototype of the ```SearchableDocument``` object before it is instantiated, and thus made available to you in your search module.\r\n\r\n**Example**\r\n\r\ninside ```customizations/SearchableDocument.js```:\r\n\r\n```javascript\r\nvar ExtendSearchableDocument = {\r\n  foo: 'bar',\r\n  printFoo: function(){console.log(this.foo)};\r\n}\r\n```\r\n\r\ninside ```customizations/search.js```:\r\n```javascript\r\nexports.execute = function(SearchableDocument, ResultSet, err){\r\n    SearchableDocument.printFoo();\r\n    // > 'bar'\r\n}\r\n```\r\n---\r\n<a name=\"resultset\"></a>\r\n##ResultSet\r\nThe ```ResultSet``` Object provides a simple API to create a uniform data structure that the default results (VIVO profile) view templates can consume.\r\n\r\nMore importantly, a method is included to ```send()``` your result set to the rendering engine once you have finished populating it.\r\n\r\n<a name=\"properties-1\"></a>\r\n###Properties\r\n###```list```\r\n*array* - An array containing a list of results to be displayed in the view template\r\n\r\n###```_numResults```\r\n*int* - An integer containing the number of results in your result set. Used and incremented by \r\n```addResult()``` to generate part of a composite key for DOM ids for results / profiles. \r\n\r\n###```score```\r\n*int* - A subjective measure of how accurate your results are, on a scale of 1-5\r\n\r\n<a name=\"methods-1\"></a>\r\n###Methods\r\n\r\n<a name=\"resultsetaddresultparams\"></a>\r\n###```ResultSet.addResult(params)```\r\n\r\n**Params**\r\n*  **params** - an object literal containing data that can be accessed in the results view templates. For the default template:\r\n  *  **params.name** - *String* - The name of the individual or organization\r\n  *  **params.title** - *String* - The title of the individual or organization. \r\n  *  **params.institution_name** - *String* - The name of the institution as it should be displayed next to an overview\r\n  *  **params.institution_shortname** - *String* - The shortened name of the institution as it should be displayed in the results view\r\n  *  **params.image_url** - *String* - The path to the image / thumbnail associated with the individual in the result view\r\n  *  **params.uri** - *String* - The URI of the individual / organization's VIVO profile\r\n  *  **params.overview** - *String* - The bio, description or overview text describing the individual / organization\r\n\r\n**Description** - accepts a params object containing meta data about a result. It will add this meta data to an array element of ```list```.\r\n\r\nNote that all of the above properties of ```params``` are optional. These are merely listed here for your convenience, as the default results view template expects them.\r\n\r\nIf you have defined a custom view template, pass in what you need instead. For example, ```ResultSet.addResult({DepartmentName:'Sociology'})``` would add a result with a ```DepartmentName``` property, which would be available to you in your custom results view template in the ```results``` variable.\r\n\r\n**Returns** - void\r\n\r\n---\r\n\r\n###```ResultSet.setScore(score)```\r\n\r\n**Params**:\r\n*  Score - *int* - a number between 1-5 that describes how accurate your result set is.\r\n\r\n**Description** - sets ```ResultSet.score``` to ```score```. Because scoring is highly subjective, you will need to write some logic to decide how accurate the results you are getting back from your search index are on a scale of 1-5. This score is displayed to the user in the default view template. If you are using a custom view template, setting a score isn't strictly necessary. \r\n\r\n**Returns** - Void\r\n\r\n**Post Condition** - ```ResultSet.score``` is set to ```score```.\r\n\r\n---\r\n\r\n<a name=\"resultsetsend\"></a>\r\n###```ResultSet.send()```\r\n\r\n**Params**: none\r\n\r\n**Description** - Passes your ```ResultSet``` instance to the rendering engine, signaling it that your processing is complete and it is safe to send data to the client. Two variables will be made available to the view template - ```results``` (containing an array of result objects / profiles) and ```score``` containing the value of ```ResultSet.score```. \r\n\r\n<a name=\"making-requests-to-a-search-index\"></a>\r\n#Making Requests to a search index\r\nWithin your search module (```customizations/search.js```), you will need to query a search index for VIVO profiles relevant to the text you received from the client. A request module is available for you in ```lib/request.js``` that makes this process easier.\r\n\r\n<a name=\"the-request-module\"></a>\r\n#The Request Module\r\nThe request module offers a thin wrapper for [request](https://github.com/mikeal/request) that abstracts error handling and returns promises for responses using [bond](https://github.com/pete-otaqui/bond). Bond is a super simple promises implementation that is really easy to use. See the examples below for more details.\r\n\r\nThe request module is available to you as ```request``` within your search module (```customizations/search.js```). \r\n\r\n###Exports\r\n\r\n<a name=\"posturi-opts-next\"></a>\r\n###```post(uri, opts, next)```\r\n\r\n**params** \r\n  *  uri - *string* - The URI you are making a request to\r\n  *  opts - *object* - Key value pairs representing request parameters\r\n  *  next - *function* - The express ```next()``` function, used for error handing in this case\r\n\r\n**Description** - Makes a HTTP post request to the specified URI\r\n\r\n**Returns** function (a promise for a HTTP response)\r\n\r\n**Example usage** \r\n\r\n```javaScript\r\nvar gettingResults = request.post('www.example.com', {id:2}, next);\r\ngettingResults.then(function(results){\r\n    //do something with your results... \r\n});\r\n```\r\n\r\n---\r\n###```get(uri, opts, next)```\r\n\r\n**params** \r\n  *  uri - *string* - The URI you are making a request to\r\n  *  opts - *object* - Key value pairs representing request parameters\r\n  *  next - *function* - The express ```next()``` function, used for error handing in this case\r\n\r\n**Description** - Makes a HTTP get request to the specified URI\r\n\r\n**Returns** function (a promise for a HTTP response)\r\n\r\n**Example usage** \r\n\r\n```javaScript\r\nvar gettingResults = request.get('www.example.com', {id:2}, next);\r\ngettingResults.then(function(results){\r\n    //do something with your results... \r\n});\r\n```\r\n\r\n<a name=\"creating-a-custom-view-template\"></a>\r\n#Creating a Custom View Template\r\nUsing custom view templates for a bookmarklet iframe, widget or result set is easy. Simply follow the naming conventions you see inside ```customizations/views/```. For example - if you would like to use a custom iframe template, replace ```bar-iframe.html.example``` with your own template, ```bar-iframe.html```. \r\n\r\nThe searchlight framework checks first to see if a custom view template exists, and uses it if it is available. Otherwise, the default view template is used to satisfy a request. \r\n\r\n\r\n<a name=\"public-assets-stylesheets-javascript-images\"></a>\r\n#Public Assets\r\nTwo publicly available static directories exist in every searchlight application. The first, is the default ```public/``` directory, which stores image, javascript and style assets for the default view templates.\r\n\r\nThe second can be found at ```customizations/public```, and is used for adding assets for custom view templates. Anything you put in this directory will be available at ```http://example-host.com/custom/```. \r\n\r\nSo, to include a custom style sheet within your custom view template in ```/customizations/views```: \r\n```html\r\n<link rel=\"stylesheet\" href=\"/custom/stylesheets/style.css'\" type=\"text/css\">\r\n```\r\n\r\n<a name=\"custom-client-side-behavior\"></a>\r\n#Custom Client Side Behavior\r\nCurrently, there are very few avenues for modifying application specific client side behavior aside from hacking framework code in ```lib/client/```. If you need to add analytics code, or some other JavaScript for your use case, you can add it in ```customizations/public/javascripts/custom.js```. \r\n\r\nThis file will be appended to the rest of the client side JavaScript and minified during the [front end build process](#building-the-front-end).\r\n\r\n<a name=\"building-the-front-end\"></a>\r\n#Building the Front End\r\nThe default front end is built for you already. If you need to rebuild it for some reason (e.g. you've been doing some hacking in ```lib/client/```) you can do so by adding ```-b``` as an option when you start the server. \r\n\r\n```bash\r\n$ node app.js -b\r\n```\r\n\r\nThis can also be accomplished with the [grunt](http://gruntjs.com/getting-started) command line tool: \r\n\r\n```bash\r\n$ grunt default\r\n``` \r\n\r\nThe Gruntfile is located in the root of the project directory, ```Gruntfile.js```.\r\n\r\n<a name=\"error-handling\"></a>\r\n#Error Handling\r\n\r\n<a name=\"handling-an-error\"></a>\r\n###Handling an error\r\nCheck out the [express docs](http://expressjs.com/guide.html#error-handling) for a detailed guide to error handling in express.\r\n\r\nIn the meantime, here is a simple example of how you might handle an error in your search module:\r\n\r\n```javascript\r\n\r\nfunction raiseShields(){\r\n\r\n  sheildStatus = enterprise.shields.up(); // Some code an intern wrote that lowers\r\n                                          // shields and spits out an error instead...\r\n  if(shieldStatus.error){\r\n    enterprise.bones.complain(\"My god Jim... It'll tear the ship apart!\");\r\n    next(shieldStatus.error);\r\n  }\r\n\r\n}();\r\n\r\n```\r\n<a name=\"error-logging\"></a>\r\n###Error Logging\r\n```lib/ErrorHandler.js``` contains a thin wrapper for [Winston](https://github.com/flatiron/winston). It is used internally as middleware for express. Both console and file system transports are used for logging, with errors logged in ```/logs/error.log.json```. See the Winston documentation for details about querying the log file programmaticly - which can be quite useful for testing and debugging. \r\n\r\nCaught exceptions are logged as run time errors. Uncaught exceptions are logged as such, and the app is killed to prevent attempts to handle future requests in an unknown state. \r\n\r\nFor maximum stability, it is recommended that you use a service like [forever](https://github.com/nodejitsu/forever) to automatically restart the server in the event of an uncaught exception.\r\n\r\n<a name=\"deployment\"></a>\r\n#Deploying the App\r\n\r\nThere are lots of guides and tutorials online for deploying node.js apps. How you should deploy will also depend a lot on your server environment / OS however, so be sure to consult the appropriate documentation.\r\n\r\nConsider running a service like [forever](https://github.com/nodejitsu/forever) or [monit](http://mmonit.com/monit/) to restart the app in the event of an [uncaught exception](#error-logging).\r\n\r\nFinally, make sure the client side of the app knows where to find resources. You can do this by editing the ```SearchLight_Application_Host``` variable in ```customizations/public/javascripts/config.js```. The host is set to ```http://127.0.0.1:3000``` for local development by default.\r\n\r\n```javascript\r\nvar SearchLight_Application_Host = 'http://somehostname.com';\r\n\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}